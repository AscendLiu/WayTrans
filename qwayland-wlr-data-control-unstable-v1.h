// This file was generated by qtwaylandscanner
// source file is wlr-data-control-unstable-v1.xml

#ifndef QT_WAYLAND_WLR_DATA_CONTROL_UNSTABLE_V1
#define QT_WAYLAND_WLR_DATA_CONTROL_UNSTABLE_V1

#include "wayland-wlr-data-control-unstable-v1-client-protocol.h"
#include <QByteArray>
#include <QString>

struct wl_registry;

QT_BEGIN_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
QT_WARNING_DISABLE_CLANG("-Wmissing-field-initializers")

namespace QtWayland {
    class  zwlr_data_control_manager_v1
    {
    public:
        zwlr_data_control_manager_v1(struct ::wl_registry *registry, uint32_t id, int version);
        zwlr_data_control_manager_v1(struct ::zwlr_data_control_manager_v1 *object);
        zwlr_data_control_manager_v1();

        virtual ~zwlr_data_control_manager_v1();

        void init(struct ::wl_registry *registry, uint32_t id, int version);
        void init(struct ::zwlr_data_control_manager_v1 *object);

        struct ::zwlr_data_control_manager_v1 *object() { return m_zwlr_data_control_manager_v1; }
        const struct ::zwlr_data_control_manager_v1 *object() const { return m_zwlr_data_control_manager_v1; }
        static zwlr_data_control_manager_v1 *fromObject(struct ::zwlr_data_control_manager_v1 *object);

        bool isInitialized() const;

        uint32_t version() const;
        static const struct ::wl_interface *interface();

        struct ::zwlr_data_control_source_v1 *create_data_source();
        struct ::zwlr_data_control_device_v1 *get_data_device(struct ::wl_seat *seat);
        void destroy();

    private:
        struct ::zwlr_data_control_manager_v1 *m_zwlr_data_control_manager_v1;
    };

    class  zwlr_data_control_device_v1
    {
    public:
        zwlr_data_control_device_v1(struct ::wl_registry *registry, uint32_t id, int version);
        zwlr_data_control_device_v1(struct ::zwlr_data_control_device_v1 *object);
        zwlr_data_control_device_v1();

        virtual ~zwlr_data_control_device_v1();

        void init(struct ::wl_registry *registry, uint32_t id, int version);
        void init(struct ::zwlr_data_control_device_v1 *object);

        struct ::zwlr_data_control_device_v1 *object() { return m_zwlr_data_control_device_v1; }
        const struct ::zwlr_data_control_device_v1 *object() const { return m_zwlr_data_control_device_v1; }
        static zwlr_data_control_device_v1 *fromObject(struct ::zwlr_data_control_device_v1 *object);

        bool isInitialized() const;

        uint32_t version() const;
        static const struct ::wl_interface *interface();

        enum error {
            error_used_source = 1, // source given to set_selection or set_primary_selection was already used before
        };

        void set_selection(struct ::zwlr_data_control_source_v1 *source);
        void destroy();
        void set_primary_selection(struct ::zwlr_data_control_source_v1 *source);

    protected:
        virtual void zwlr_data_control_device_v1_data_offer(struct ::zwlr_data_control_offer_v1 *id);
        virtual void zwlr_data_control_device_v1_selection(struct ::zwlr_data_control_offer_v1 *id);
        virtual void zwlr_data_control_device_v1_finished();
        virtual void zwlr_data_control_device_v1_primary_selection(struct ::zwlr_data_control_offer_v1 *id);

    private:
        void init_listener();
        static const struct zwlr_data_control_device_v1_listener m_zwlr_data_control_device_v1_listener;
        static void handle_data_offer(
            void *data,
            struct ::zwlr_data_control_device_v1 *object,
            struct ::zwlr_data_control_offer_v1 *id);
        static void handle_selection(
            void *data,
            struct ::zwlr_data_control_device_v1 *object,
            struct ::zwlr_data_control_offer_v1 *id);
        static void handle_finished(
            void *data,
            struct ::zwlr_data_control_device_v1 *object);
        static void handle_primary_selection(
            void *data,
            struct ::zwlr_data_control_device_v1 *object,
            struct ::zwlr_data_control_offer_v1 *id);
        struct ::zwlr_data_control_device_v1 *m_zwlr_data_control_device_v1;
    };

    class  zwlr_data_control_source_v1
    {
    public:
        zwlr_data_control_source_v1(struct ::wl_registry *registry, uint32_t id, int version);
        zwlr_data_control_source_v1(struct ::zwlr_data_control_source_v1 *object);
        zwlr_data_control_source_v1();

        virtual ~zwlr_data_control_source_v1();

        void init(struct ::wl_registry *registry, uint32_t id, int version);
        void init(struct ::zwlr_data_control_source_v1 *object);

        struct ::zwlr_data_control_source_v1 *object() { return m_zwlr_data_control_source_v1; }
        const struct ::zwlr_data_control_source_v1 *object() const { return m_zwlr_data_control_source_v1; }
        static zwlr_data_control_source_v1 *fromObject(struct ::zwlr_data_control_source_v1 *object);

        bool isInitialized() const;

        uint32_t version() const;
        static const struct ::wl_interface *interface();

        enum error {
            error_invalid_offer = 1, // offer sent after wlr_data_control_device.set_selection
        };

        void offer(const QString &mime_type);
        void destroy();

    protected:
        virtual void zwlr_data_control_source_v1_send(const QString &mime_type, int32_t fd);
        virtual void zwlr_data_control_source_v1_cancelled();

    private:
        void init_listener();
        static const struct zwlr_data_control_source_v1_listener m_zwlr_data_control_source_v1_listener;
        static void handle_send(
            void *data,
            struct ::zwlr_data_control_source_v1 *object,
            const char *mime_type,
            int32_t fd);
        static void handle_cancelled(
            void *data,
            struct ::zwlr_data_control_source_v1 *object);
        struct ::zwlr_data_control_source_v1 *m_zwlr_data_control_source_v1;
    };

    class  zwlr_data_control_offer_v1
    {
    public:
        zwlr_data_control_offer_v1(struct ::wl_registry *registry, uint32_t id, int version);
        zwlr_data_control_offer_v1(struct ::zwlr_data_control_offer_v1 *object);
        zwlr_data_control_offer_v1();

        virtual ~zwlr_data_control_offer_v1();

        void init(struct ::wl_registry *registry, uint32_t id, int version);
        void init(struct ::zwlr_data_control_offer_v1 *object);

        struct ::zwlr_data_control_offer_v1 *object() { return m_zwlr_data_control_offer_v1; }
        const struct ::zwlr_data_control_offer_v1 *object() const { return m_zwlr_data_control_offer_v1; }
        static zwlr_data_control_offer_v1 *fromObject(struct ::zwlr_data_control_offer_v1 *object);

        bool isInitialized() const;

        uint32_t version() const;
        static const struct ::wl_interface *interface();

        void receive(const QString &mime_type, int32_t fd);
        void destroy();

    protected:
        virtual void zwlr_data_control_offer_v1_offer(const QString &mime_type);

    private:
        void init_listener();
        static const struct zwlr_data_control_offer_v1_listener m_zwlr_data_control_offer_v1_listener;
        static void handle_offer(
            void *data,
            struct ::zwlr_data_control_offer_v1 *object,
            const char *mime_type);
        struct ::zwlr_data_control_offer_v1 *m_zwlr_data_control_offer_v1;
    };
}

QT_WARNING_POP
QT_END_NAMESPACE

#endif
